public class SubtreeOfAnotherTree {
}

/*
Time: O(n + m)
Space: O(Max(n, m))

Generating a unique hash value for a tree and comparing the hash values to compare two trees.
 */
class Solution {

    private long MOD_1 = 10000001441L, MOD_2 = 10000004659L;

    public boolean isSubtree(TreeNode root, TreeNode subRoot) {

        long[] subRootHash = generateTreeHash(subRoot, null);

        long[] subRootHashCheck = generateTreeHash(root, subRootHash);

        boolean subTree;

        if(subRootHashCheck == null) {
            subTree = true;
        }
        else {
            subTree = false;
        }

        return subTree;
    }

    private long[] generateTreeHash(TreeNode root, long[] compare) {
        long[] hash = new long[2];

        if(root == null) {
            hash[0] = 3;
            hash[1] = 7;
        }
        else {
            long[] leftTreeHash = generateTreeHash(root.left, compare);
            long[] rightTreeHash = generateTreeHash(root.right, compare);

            if(leftTreeHash == null || rightTreeHash == null) {
                hash = null;
            }
            else {
                hash[0] = ((leftTreeHash[0] << 5) + (rightTreeHash[0] << 3) + root.val) % MOD_1;
                hash[1] = ((leftTreeHash[1] << 5) + (rightTreeHash[1] << 3) + root.val) % MOD_2;

                if(compare != null) {
                    if(compare[0] == hash[0] && compare[1] == hash[1]) {
                        hash = null;
                    }
                }
            }
        }

        return hash;
    }
}

/*
Time: O(n + m) to O(m*n) depending on the algorothm used for comparing strings
Space: O(n + m), for recursively traversing the the tree and generating its unique representation

 Unique representation of a tree can be generated by populating it's pre or post order traversal with # for null neighbors.

 Generate representation for each of the two given trees and check whether the representation of root contains
 the representation of sub-root as a substring
 */
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {

        StringBuilder rootRep = new StringBuilder();
        StringBuilder subRootRep = new StringBuilder();

        generateTreeRepresentation(root, rootRep);
        generateTreeRepresentation(subRoot, subRootRep);

        return rootRep.toString().contains(subRootRep.toString());
    }

    private void generateTreeRepresentation(TreeNode root, StringBuilder rep) {
        if(root != null) {
            rep.append("^");
            rep.append(root.val);
            generateTreeRepresentation(root.left, rep);
            generateTreeRepresentation(root.right, rep);
        }
        else {
            rep.append("#");
        }
    }
}

// Generating intermediate representation with in-order traversal
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {

        StringBuilder rootRep = new StringBuilder();
        StringBuilder subRootRep = new StringBuilder();

        generateTreeRepresentation(root, rootRep);
        generateTreeRepresentation(subRoot, subRootRep);

        return rootRep.toString().contains(subRootRep.toString());
    }

    private void generateTreeRepresentation(TreeNode root, StringBuilder rep) {
        if(root != null) {
            rep.append("^");
            generateTreeRepresentation(root.left, rep);
            rep.append(root.val);
            generateTreeRepresentation(root.right, rep);
            rep.append("^");
        }
        else {
            rep.append("#");
        }
    }
}
// Generating intermediate representation with post-order traversal
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {

        StringBuilder rootRep = new StringBuilder();
        StringBuilder subRootRep = new StringBuilder();

        generateTreeRepresentation(root, rootRep);
        generateTreeRepresentation(subRoot, subRootRep);

        return rootRep.toString().contains(subRootRep.toString());
    }

    private void generateTreeRepresentation(TreeNode root, StringBuilder rep) {
        if(root != null) {
            generateTreeRepresentation(root.left, rep);
            generateTreeRepresentation(root.right, rep);
            rep.append(root.val);
            rep.append("^");
        }
        else {
            rep.append("#");
        }
    }
}

/*
Time: O(m*n)
Space: O(m + n)

 At each node, check whether the subtree rooted at that node is equal to the sub-tree that's passed
 */
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {

        boolean isSubtree = false;

        if(root != null) {
            if(root.val == subRoot.val) {
                isSubtree = checkEquality(root, subRoot);
            }

            if(!isSubtree) {
                isSubtree = isSubtree(root.left, subRoot);

                if(!isSubtree) {
                    isSubtree = isSubtree(root.right, subRoot);
                }
            }
        }
        else {
            isSubtree = false;
        }

        return isSubtree;
    }

    private boolean checkEquality(TreeNode tree1, TreeNode tree2) {

        boolean same;

        if(tree1 != null && tree2 != null) {
            if(tree1.val != tree2.val) {
                same = false;
            }
            else {
                same = checkEquality(tree1.left, tree2.left);

                if(same) {
                    same = checkEquality(tree1.right, tree2.right);
                }
            }
        }
        else if(tree1 == null && tree2 == null) {
            same = true;
        }
        else {
            same = false;
        }

        return same;
    }
}